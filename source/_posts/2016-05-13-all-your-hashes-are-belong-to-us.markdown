---
layout: post
title: "All Your Hashes Are Belong To Us"
date: 2016-05-13 18:07:01 -0500
comments: true
categories: [ios, reverse engineering, api]
description: "All Your Hashes Are Belong To Us"
---

I've seen quite a few tricks of apps trying to hide credentials to access APIs to prevent reverse-engineering. Let me say it again: if you assume that your deliverable is secure, and use security by obscurity, you are doing it wrong. Sigh. If you delivery the binary with credentials to the user, assume that they will be able eventually to recover it.

Recently I needed to replicate API access for a major ticketing website. They use Digest authentication to generate access tokens which expire every 5 minutes. I was able to intercept almost all the missing pieces of puzzle, including API key using mitmproxy as usual. 

<!-- more -->

### Brute force

The only piece which was missing was the password, or API secret. Since from a look at the Authorization header I was able to deduct the hashing algorithm from the fact that it's a digest authentication with quality of protection (qop), my first idea was to brute-force the password. Here is the algorithm.

{% codeblock %}
HA1 = MD5(username:realm:password)
HA2 = MD5(method:digestURI)
response = MD5(HA1:nonce:nonceCount:cnonce:qop:HA2)
{% endcodeblock %}

As this particular type of digest authentication uses qop, it means that you can't apply a replay attack to it, and response expires every 5 seconds due to nonce which is based on timestamp aand generated by the server. The way it works, is that a client sends a request to the server with no Authorization header and gets 401 and a nonce in response. Then it calculates a response based on that information. The client then sends this info to the server in a consecutive request within Authorization header. As the client and the server have the same information to calculate the response, the server decides whether to authenticate the user based on this information.

Unfortunately, brute-force attack wasn't exactly feasible, as the only assumption I had was that the password has the same length and structure as the username (26 characters lowercase alphanumeric). It was a wild guess of course, but turned out to be right. I'd then need to reverse MD5 two times: first to get HA1 MD5 digest which is 32 characters (36^32 combinations) and second to get the password (presumably 36^26 combinations). Even though MD5 is one of the weakest hash algorithms out there, even at a rate of 200,000 hashes/s which is some of the best for modern GPUs, it would take about 1e36 years to go through all the combinations. That takes longer than grabbing a beer from a fridge, so naturally I had to pass on this tempting opportunity.

### Extract it from a keychain

It's great the developers store passwords and certificates in the iOS Keychain. This is a way to go. The way it works in iOS is that you can assign your credentials to a keychain group, so that only your app can access them. Overall, you iOS passcode or fingerprint works as a key to decrypt the keychain and once you unlock your phone, you can dump all the internet passwords and certificates. The keychain persistence layer is a simple sqlite database. I use the tool called [Keychain dumper](https://github.com/ptoomey3/Keychain-Dumper) to check it out. Unfortunately the password I was looking for wasn't there, tough luck. 

### Time to dig into the binary

So, by inziping IPA, it didn't look that the password is retrieved from resources. Neither I've spotted anything password-like by spoofing http requests coming from the app. Which leaves as with the binary itself. By default all the IPA file from App Store are encrypted, so you need to decrypt them first. I use a handy tool called [Dump Decrypted](https://github.com/stefanesser/dumpdecrypted) which saves you some time, although you can use gdb to dump memory directly.

Once decrypted I use Hopper Disassembler to analyses the structure of the binary. Particularly I'd look for strings, as the password might be hardcoded in the binary, or at the methods of AppDelegate and see if there are methods to retrieve said password. In this case, it looks that the password has been obfuscated, but I found a method call of the delegate which allows you to retrieve it in runtime.

### Play with the app in runtime

This is one of my favorite tools for iOS reverse-engineering. It's called [Cycrypt](http://www.cycript.org) and it allows you to explore running iOS application and inject custom code. So I've attached to my running app and accessed an instance of AppDelegate to call the method to display the API secret. Done and done.

### So, is there a way from preventing my API from reverse-engineering?

I don't think so. It's always a matter of time and determination for someone to find a way to replicate your app functionality. Here is a rule of thumb: don't store any secret credentials in a deliverable.